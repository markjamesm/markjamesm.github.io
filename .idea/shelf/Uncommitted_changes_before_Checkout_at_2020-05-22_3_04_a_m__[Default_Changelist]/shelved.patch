Index: _posts/2020-05-22-making-a-roguelike-in-c#-with-gorogue-sadconsole-part-two.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nlayout: post\ntitle: Making a roguelike in C# using GoRogue and SadConsole (Part Two)\nheader-img: \"img/posts/runic-quest-part-one-final.jpg\"\ntags: [tutorials, programming projects, c#] \n---\n\nAfter setting up the GoRogue Helpers template and making a few basic changes to it in [Part One](https://markjames.dev/2020-05-21-making-a-roguelike-in-c-with-gorogue-sadconsole-part-one/) of this tutorial series, Part Two looks to dig into the code even deeper and implement some additional features to make our game feel more like a game. Assuming that you completed part one, you should have a basic game which compiles and lets you explore a fairly big dungeon map which contains static enemies which you can't attack. \n\n## Creating a UI Manager\n\nThe first thing that I wanted to do going forward, was to implement a proper UI manager. Fortunately, [Part 8](https://ansiware.com/tutorial-part-8-user-interface-manager-v8/) of the Ansiware tutorial explains how to implement a UI manager. \n\nThe first thing I did was to create a class called UIManager.cs, and I copied and pasted the Ansiware code to use as a blueprint, modifying it for my game name:\n\n```csharp\nusing Microsoft.Xna.Framework;\nusing SadConsole;\nnamespace RunicQuest\n{\n    // Creates/Holds/Destroys all consoles used in the game\n    // and makes consoles easily addressable from a central place.\n    public class UIManager : ContainerConsole\n    {\n        public ScrollingConsole MapConsole;\n\n        public UIManager()\n        {\n            // must be set to true\n            // or will not call each child's Draw method\n            IsVisible = true;\n            IsFocused = true;\n\n            // The UIManager becomes the only\n            // screen that SadConsole processes\n            Parent = SadConsole.Global.CurrentScreen;\n        }\n\n        // Creates all child consoles to be managed\n        // make sure they are added as children\n        // so they are updated and drawn\n        public void CreateConsoles()\n        {\n            \n        }\n\n    }\n}\n```\n\nHere we have a lot of great base code! The next step is to hook in the UI Manager to our MapScreen class. Currently, the MapScreen.cs file contains the following line of code:\n\n```csharp\ninternal class MapScreen : ContainerConsole\n```\n\nSince our UIManager extends the ContainerConsole base class, I wired it up to UIManager instead:\n\n```csharp\ninternal class MapScreen : UIManager\n```\n\nKeeping in line with Ansiware's theme of encapsulation, the next step was to move the map generation code outside of GameLoop.cs (previously named Program.cs, but I renamed it for readability) and into the UIManager. In order to do so, I removed the references to the Map Height and Width, as well as the details and added the followingt code inside UIManager.cs:\n\n```csharp\n    public class UIManager : ContainerConsole\n    {\n        // Set the map and viewport dimensions.\n        public const int ViewPortWidth = 80;\n        public const int ViewPortHeight = 25;\n\n        private const int MapWidth = 500;\n        private const int MapHeight = 500;\n```\n\nNote that the ViewPort height and width are set to a public constant, this is because we still need to use them inside our GameLoop.cs to create the main window: \n\n```csharp\n        private static void Main()\n        {\n            // Setup the engine and create the main window.\n            SadConsole.Game.Create(UIManager.ViewPortWidth, UIManager.ViewPortHeight);\n```\n\nNow we need to create the Map inside of our UIManager class, and we do so inside of the CreateConsoles() method like this:\n\n```csharp\n        public void CreateConsoles()\n        {\n            // Generate and display the map\n            MapScreen = new MapScreen(MapWidth, MapHeight, ViewPortWidth, ViewPortHeight);\n        }\n```\n\nCreateConsoles() creates all the child consoles to be managed, and makes sure that they are added as children, updated, and drawn.\n\nNow we need to wire up the UIManager to our GameLoop. Firstly, we declare our UIManager:\n\n```csharp\n    internal class GameLoop\n    {\n\n        public static UIManager UIManager;\n```\n\nand then hook in UIManager inside our init method:\n\n```csharp\n            // Create our UI Manager and then spawn our consoles.\n            UIManager = new UIManager();\n            UIManager.CreateConsoles();\n```\n\nAt this point, if you save and run the code you should see the following window appear:\n\n![Runic Quest UI Manager](https://markjames.dev/img/posts/runic-quest/runic-quest-ui-manager.jpg \"Runic Quest roguelike using a UI Manager\")\n\nSuccess! The GoRogue template map generator is now hooked into our freshly minted UIManager class! \n\n## Implement a Message Logger\n\nAlthough this is a great first step, now is a good time to make an attempt at hooking in a basic message log. Again, I'm going to be borowing code from Ansiware, this time from [Part 9](https://ansiware.com/tutorial-part-9-message-log-v8/)\n\nCreating MessageLogWindow.cs, I filled it with the following code:\n\n```csharp\nusing System.Collections.Generic;\nusing SadConsole;\nusing System;\nusing Microsoft.Xna.Framework;\n\nnamespace RunicQuest\n{\n    //A scrollable window that displays messages\n    //using a FIFO (first-in-first-out) Queue data structure\n    public class MessageLogWindow : Window\n    {\n        //max number of lines to store in message log\n        private static readonly int _maxLines = 50;\n\n        // a Queue works using a FIFO structure, where the first line added\n        // is the first line removed when we exceed the max number of lines\n        private readonly Queue<string> _lines;\n\n        // the messageConsole displays the active messages\n        private SadConsole.ScrollingConsole _messageConsole;\n\n        // Create a new window with the title centered\n        // the window is draggable by default\n        public MessageLogWindow(int width, int height, string title) : base(width, height)\n        {\n            // Ensure that the window background is the correct colour\n        //    Theme.WindowTheme.FillStyle.Background = DefaultBackground;\n            _lines = new Queue<string>();\n            CanDrag = true;\n            Title = title.Align(HorizontalAlignment.Center, Width);\n\n            // add the message console, reposition, and add it to the window\n            _messageConsole = new SadConsole.ScrollingConsole(width - 1, height - 1);\n            _messageConsole.Position = new Point(1, 1);\n            Children.Add(_messageConsole);\n        }\n\n        //Remember to draw the window!\n        public override void Draw(TimeSpan drawTime)\n        {\n            base.Draw(drawTime);\n        }\n\n        //add a line to the queue of messages\n        public void Add(string message)\n        {\n            _lines.Enqueue(message);\n            // when exceeding the max number of lines remove the oldest one\n            if (_lines.Count > _maxLines)\n            {\n                _lines.Dequeue();\n            }\n            // Move the cursor to the last line and print the message.\n            _messageConsole.Cursor.Position = new Point(1, _lines.Count);\n            _messageConsole.Cursor.Print(message + \"\\n\");\n        }\n    }\n}\n```\n\nNext, I declared my MessageLogWindow inside my UIManager class, and then added the following code to the CreateConsoles() method just below the other code:\n\n            // Create the message log window and set its position.\n            MessageLog = new MessageLogWindow(ViewPortWidth, ViewPortHeight / 4, \"Message Log\");\n            Children.Add(MessageLog);\n            MessageLog.Show();\n            MessageLog.Position = new Point(0, 20);\n\n            // Print a test message\n            MessageLog.Add(\"Testing 123\");\n            \nMuch like we did with the MapScreen, we create a MessageLog and then add it as a child of the UIManager. We then display the message log at position (0, 20) and finally display a test message. I played around with the size parameters of the MessageLog for a bit, and I liked how this looked through trial and error.\n\nRunning my code at this point produces the following result:\n\n![Runic Quest MessageLogger](https://markjames.dev/img/posts/runic-quest/runic-quest-message-log-window.jpg \"Runic Quest roguelike with message log\")\n\nLooking good! \n\n## Add Scrolling to the Message Logger\n\nSince a lot of action will be happening in our game, we need a way to handle streams of text by adding a Scrollbar to our MessageLogWindow. In order to do so, take a look at [Part 9](https://ansiware.com/tutorial-part-9-message-log-v8/) of Ansiware's tutorial, and integrate the code he provides into your MessageLog.cs. His explanation of the MessagerLogger is terrific, and there's no point in reinventing the wheel! Should you get stuck, you can take a look at my [commit here](https://github.com/markjamesm/runic-quest/commit/5583c895b7c8d8e822b88cfcfcf607b6e5c4ce08). Building the code at this stage looks like this: \n\n![Runic Quest scrollbar](https://markjames.dev/img/posts/runic-quest/runic-quest-scrollbar.jpg \"Runic Quest with Sadconsole scrollbar implemented\")\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- _posts/2020-05-22-making-a-roguelike-in-c#-with-gorogue-sadconsole-part-two.md	(revision 32c632a7ba157e508a7bdad8784acb7c8bc9c948)
+++ _posts/2020-05-22-making-a-roguelike-in-c#-with-gorogue-sadconsole-part-two.md	(date 1590130910844)
@@ -201,10 +201,16 @@
 
 ![Runic Quest MessageLogger](https://markjames.dev/img/posts/runic-quest/runic-quest-message-log-window.jpg "Runic Quest roguelike with message log")
 
-Looking good! 
+Looking good! The great part about the UI Manager is that we can move the message logger window around by dragging it should we so choose.
 
 ## Add Scrolling to the Message Logger
 
 Since a lot of action will be happening in our game, we need a way to handle streams of text by adding a Scrollbar to our MessageLogWindow. In order to do so, take a look at [Part 9](https://ansiware.com/tutorial-part-9-message-log-v8/) of Ansiware's tutorial, and integrate the code he provides into your MessageLog.cs. His explanation of the MessagerLogger is terrific, and there's no point in reinventing the wheel! Should you get stuck, you can take a look at my [commit here](https://github.com/markjamesm/runic-quest/commit/5583c895b7c8d8e822b88cfcfcf607b6e5c4ce08). Building the code at this stage looks like this: 
 
 ![Runic Quest scrollbar](https://markjames.dev/img/posts/runic-quest/runic-quest-scrollbar.jpg "Runic Quest with Sadconsole scrollbar implemented")
+
+## Conlusion
+
+In this part of the roguelike tutorial, we extended the functionality of our game significantly by creating a window manager and then adding both the game map and a scrolling message log! With a basic UI in place now, we can now start to think about the gameplay a bit more, and in the next step of the tutorial we'll look into creating a basic combat system!
+
+As an aside, at this point I created a [Github workflow](https://github.com/markjamesm/runic-quest/blob/master/.github/workflows/dotnetcore.yml) in order to setup continuous integration through Github actions. With CI now setup, the next step is to write some unit tests (which I'll be covering in a future post!). 
\ No newline at end of file
